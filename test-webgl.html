<!DOCTYPE html>
<html>
<head>
    <title>WebGL Voxel Test</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="info">
        WebGL Voxel Test<br>
        WASD: Move, Mouse: Look<br>
        <div id="debug"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        const debug = document.getElementById('debug');
        
        if (!gl) {
            debug.textContent = 'WebGL not supported!';
        } else {
            debug.textContent = 'WebGL supported!';
        }
        
        // Simple vertex shader
        const vertexSource = `
            attribute vec3 position;
            attribute vec3 color;
            uniform mat4 mvpMatrix;
            varying vec3 vColor;
            
            void main() {
                gl_Position = mvpMatrix * vec4(position, 1.0);
                vColor = color;
            }
        `;
        
        // Simple fragment shader
        const fragmentSource = `
            precision mediump float;
            varying vec3 vColor;
            
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;
        
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
        
        function createProgram() {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
        
        // Create a simple cube
        function createCube(x, y, z, color) {
            const vertices = [
                // Front face
                x, y, z+1,  x+1, y, z+1,  x+1, y+1, z+1,
                x, y, z+1,  x+1, y+1, z+1,  x, y+1, z+1,
                
                // Back face
                x+1, y, z,  x, y, z,  x, y+1, z,
                x+1, y, z,  x, y+1, z,  x+1, y+1, z,
                
                // Top face
                x, y+1, z,  x, y+1, z+1,  x+1, y+1, z+1,
                x, y+1, z,  x+1, y+1, z+1,  x+1, y+1, z,
                
                // Bottom face
                x, y, z+1,  x, y, z,  x+1, y, z,
                x, y, z+1,  x+1, y, z,  x+1, y, z+1,
                
                // Right face
                x+1, y, z+1,  x+1, y, z,  x+1, y+1, z,
                x+1, y, z+1,  x+1, y+1, z,  x+1, y+1, z+1,
                
                // Left face
                x, y, z,  x, y, z+1,  x, y+1, z+1,
                x, y, z,  x, y+1, z+1,  x, y+1, z
            ];
            
            const colors = [];
            for (let i = 0; i < 36; i++) { // 6 faces * 6 vertices
                colors.push(color[0], color[1], color[2]);
            }
            
            return { vertices, colors };
        }
        
        // Matrix functions
        function perspective(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ]);
        }
        
        function lookAt(eye, center, up) {
            const f = normalize(subtract(center, eye));
            const s = normalize(cross(f, up));
            const u = cross(s, f);
            
            return new Float32Array([
                s[0], u[0], -f[0], 0,
                s[1], u[1], -f[1], 0,
                s[2], u[2], -f[2], 0,
                -dot(s, eye), -dot(u, eye), dot(f, eye), 1
            ]);
        }
        
        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }
        
        // Vector math helpers
        function subtract(a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; }
        function normalize(v) {
            const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / len, v[1] / len, v[2] / len];
        }
        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }
        function dot(a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; }
        
        // Main setup
        const program = createProgram();
        if (!program) {
            debug.textContent = 'Failed to create shader program!';
        } else {
            gl.useProgram(program);
            
            // Create test cube data
            const cubeData = createCube(0, 0, 0, [1, 0, 0]); // Red cube
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeData.vertices), gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeData.colors), gl.STATIC_DRAW);
            
            // Get attribute locations
            const positionLoc = gl.getAttribLocation(program, 'position');
            const colorLoc = gl.getAttribLocation(program, 'color');
            const mvpLoc = gl.getUniformLocation(program, 'mvpMatrix');
            
            // Setup WebGL state
            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.1, 0.1, 0.2, 1.0);
            
            // Camera setup
            let cameraPos = [3, 3, 3];
            let cameraTarget = [0, 0, 0];
            let cameraUp = [0, 1, 0];
            
            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                // Create matrices
                const proj = perspective(45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100);
                const view = lookAt(cameraPos, cameraTarget, cameraUp);
                const mvp = multiply(proj, view);
                
                // Set uniforms
                gl.uniformMatrix4fv(mvpLoc, false, mvp);
                
                // Bind position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLoc);
                gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
                
                // Bind color attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.enableVertexAttribArray(colorLoc);
                gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
                
                // Draw
                gl.drawArrays(gl.TRIANGLES, 0, 36);
                
                debug.innerHTML = `
                    WebGL Test<br>
                    Camera: [${cameraPos.map(v => v.toFixed(1)).join(', ')}]<br>
                    Vertices: 36 (12 triangles)
                `;
                
                requestAnimationFrame(render);
            }
            
            // Simple rotation animation
            let angle = 0;
            setInterval(() => {
                angle += 0.01;
                cameraPos = [
                    Math.cos(angle) * 5,
                    3,
                    Math.sin(angle) * 5
                ];
            }, 16);
            
            render();
        }
    </script>
</body>
</html>